{"paper_id": "83fec1e348f33f23efdc912f565e5f444724aeab", "metadata": {"title": "Aggregated Private Information Retrieval A First Practical Implementation to Support Large-Scale Disease Analytics", "authors": [{"first": "Lukas", "middle": [], "last": "Helminger", "suffix": "", "affiliation": {"laboratory": "", "institution": "Graz University of Technology", "location": {"settlement": "Graz", "country": "Austria"}}, "email": ""}, {"first": "Daniel", "middle": [], "last": "Kales", "suffix": "", "affiliation": {"laboratory": "", "institution": "Graz University of Technology", "location": {"settlement": "Graz", "country": "Austria"}}, "email": ""}, {"first": "Christian", "middle": [], "last": "Rechberger", "suffix": "", "affiliation": {"laboratory": "", "institution": "Graz University of Technology", "location": {"settlement": "Graz", "country": "Austria"}}, "email": ""}, {"first": "Roman", "middle": [], "last": "Walch", "suffix": "", "affiliation": {"laboratory": "", "institution": "Graz University of Technology", "location": {"settlement": "Graz", "country": "Austria"}}, "email": ""}]}, "abstract": [{"text": "With the outbreak of the coronavirus, governments rely more and more on location data shared by European mobile network operators to monitor the advancements of the disease. In order to comply with often strict privacy requirements, this location data, however, has to be anonymized, limiting its usefulness for making statements about a filtered part of the population, like already infected people. In this research, we aim to assist with the disease tracking efforts by designing a protocol to detect coronavirus hotspots from mobile data while still maintaining compliance with privacy expectations. We use various state-of-the-art privacy-preserving cryptographic primitives to design a protocol that can best be described as aggregated private information retrieval (APIR). Our protocol is based on homomorphic encryption, with additional measures to protect against malicious requests from clients. We have implemented our APIR protocol in the SEAL library and tested it for parameters suitable to create a coronavirus hotspot map for entire nationstates. This demonstrates that it is feasible to apply our APIR protocol to support nationwide disease analysis while still preserve the privacy of infected people.", "cite_spans": [], "ref_spans": [], "section": "Abstract"}], "body_text": [{"text": "Due to the ongoing global threat of the SARS-CoV-2 virus, a number of technological approaches are currently developed to help reduce its spread and impact. A lot of focus is on automatic contact tracing, challenges include privacyfriendliness, scalability and utility, efforts include [22, 7, 15, 6, 10, 16, 50, 1, 31, 45, 51] .", "cite_spans": [{"start": 286, "end": 290, "text": "[22,", "ref_id": "BIBREF21"}, {"start": 291, "end": 293, "text": "7,", "ref_id": "BIBREF6"}, {"start": 294, "end": 297, "text": "15,", "ref_id": "BIBREF14"}, {"start": 298, "end": 300, "text": "6,", "ref_id": "BIBREF5"}, {"start": 301, "end": 304, "text": "10,", "ref_id": "BIBREF9"}, {"start": 305, "end": 308, "text": "16,", "ref_id": "BIBREF15"}, {"start": 309, "end": 312, "text": "50,", "ref_id": "BIBREF49"}, {"start": 313, "end": 315, "text": "1,", "ref_id": "BIBREF0"}, {"start": 316, "end": 319, "text": "31,", "ref_id": "BIBREF30"}, {"start": 320, "end": 323, "text": "45,", "ref_id": "BIBREF44"}, {"start": 324, "end": 327, "text": "51]", "ref_id": "BIBREF50"}], "ref_spans": [], "section": "Introduction"}, {"text": "These approaches crucially rely on sizable parts of the population using smartphones, enabling Bluetooth, and installing a new App on their phones. In contrast, our proposal does not help with contact tracing, but gives potentially useful epidemiological information to health authorities without requiring people to carry around smartphones, as any mobile phone will be sufficient, and Bluetooth is also not needed.", "cite_spans": [], "ref_spans": [], "section": "Introduction"}, {"text": "Mobile network operators increasingly share location data to manage the coronavirus. Example: Governments in Italy, Germany, and Austria are relying on this metadata to monitor how people are complying with stay-at-home orders 3 .", "cite_spans": [{"start": 227, "end": 228, "text": "3", "ref_id": "BIBREF2"}], "ref_spans": [], "section": "Introduction"}, {"text": "In addition, the EU Commission urged Europe's biggest mobile network operators to hand over location data in the coronavirus fight 4 . In order to respect Europe's strict privacy requirements, mobile network operators only share anonymous, aggregated information that they have already gathered. Other types of such aggregated data sharing are e.g. provided by Google 5 .", "cite_spans": [{"start": 131, "end": 132, "text": "4", "ref_id": "BIBREF3"}, {"start": 361, "end": 369, "text": "Google 5", "ref_id": null}], "ref_spans": [], "section": "Introduction"}, {"text": "Although this information is useful, it has its limitations. After the process of anonymization and aggregation, it is only possible to make statements about the whole population. For example, the shared data can not be used to question whether there is a difference in behavior between people who got infected with Sars-Cov-2 and those who did not. Consequently, it is impossible with this data to detect public places where there is a significantly higher risk of getting infected with Sars-CoV-2 (hotspots). This, in turn, could be valuable knowledge in the further containment of Sars-CoV-2. The question is if there is a way to find Sars-CoV-2 hotspots without undermining privacy requirements. Landau in [39] independently also motivates increased efforts in aggregated location tracking as contact tracing may not work as well as hoped.", "cite_spans": [{"start": 710, "end": 714, "text": "[39]", "ref_id": "BIBREF38"}], "ref_spans": [], "section": "Introduction"}, {"text": "This research aims to construct a protocol for detecting coronavirus hotspots from mobile data in accordance with strict privacy requirements. To accomplish this, we design a specialized private information retrieval (PIR) protocol.", "cite_spans": [], "ref_spans": [], "section": "Introduction"}, {"text": "PIR protocols, as introduced by Chor et al. [20] , aim to realize efficient methods for a client to retrieve elements from a database managed by one or many untrusted servers. Thereby, none of the involved servers should learn which element was retrieved by the client. In this paper, we are interested in the single-server variants, namely computational PIR (CPIR), which rely on cryptographic hardness assumptions to hide the query from the server. Recent work [43, 14, 26, 38, 40, 41, 52, 3] has heavily improved on the original ideas of Chor et al. Many CPIR implementations use homomorphic encryption (HE) to hide the queries from the server while still allowing him to perform operations on the query.", "cite_spans": [{"start": 44, "end": 48, "text": "[20]", "ref_id": "BIBREF19"}, {"start": 463, "end": 467, "text": "[43,", "ref_id": "BIBREF42"}, {"start": 468, "end": 471, "text": "14,", "ref_id": "BIBREF13"}, {"start": 472, "end": 475, "text": "26,", "ref_id": "BIBREF25"}, {"start": 476, "end": 479, "text": "38,", "ref_id": "BIBREF37"}, {"start": 480, "end": 483, "text": "40,", "ref_id": "BIBREF39"}, {"start": 484, "end": 487, "text": "41,", "ref_id": "BIBREF40"}, {"start": 488, "end": 491, "text": "52,", "ref_id": "BIBREF51"}, {"start": 492, "end": 494, "text": "3]", "ref_id": "BIBREF2"}], "ref_spans": [], "section": "Introduction"}, {"text": "HE is a cryptographic primitive that allows performing computations on encrypted data without knowing the secret decryption key. The first fully homomorphic encryption (FHE) scheme, which in theory allows computing all possible functions on encrypted data, was introduced by Gentry [29] in 2009 and has been drastically improved upon by followup publications [12, 11, 28, 18, 19] . However, the limitation of FHE schemes is that they add a substantial perfor-3 https://www.reuters.com/article/us-health-coronavirus-europe-telecom s/european-mobile-operators-share-data-for-coronavirus-fight-idUSKBN 2152C2 4 https://www.sciencemag.org/news/2020/03/cellphone-tracking-could-hel p-stem-spread-coronavirus-privacy-price 5 https://www.google.com/covid19/mobility/ mance penalty of several orders of magnitude compared to performing equivalent computations in plain. Nevertheless, recent publications have shown, that highly optimized protocols can leverage homomorphic encryption to increase privacy of complex tasks, like machine learning [23, 35, 21, 9, 8, 5, 37, 36] .", "cite_spans": [{"start": 282, "end": 286, "text": "[29]", "ref_id": "BIBREF28"}, {"start": 359, "end": 363, "text": "[12,", "ref_id": "BIBREF11"}, {"start": 364, "end": 367, "text": "11,", "ref_id": "BIBREF10"}, {"start": 368, "end": 371, "text": "28,", "ref_id": "BIBREF27"}, {"start": 372, "end": 375, "text": "18,", "ref_id": "BIBREF17"}, {"start": 376, "end": 379, "text": "19]", "ref_id": "BIBREF18"}, {"start": 1036, "end": 1040, "text": "[23,", "ref_id": "BIBREF22"}, {"start": 1041, "end": 1044, "text": "35,", "ref_id": "BIBREF34"}, {"start": 1045, "end": 1048, "text": "21,", "ref_id": "BIBREF20"}, {"start": 1049, "end": 1051, "text": "9,", "ref_id": "BIBREF8"}, {"start": 1052, "end": 1054, "text": "8,", "ref_id": "BIBREF7"}, {"start": 1055, "end": 1057, "text": "5,", "ref_id": "BIBREF4"}, {"start": 1058, "end": 1061, "text": "37,", "ref_id": "BIBREF36"}, {"start": 1062, "end": 1065, "text": "36]", "ref_id": "BIBREF35"}], "ref_spans": [], "section": "Introduction"}, {"text": "However, PIR protocols, by definition, do not hide individual database entries from clients. In this paper, we want to go one step further by using HE to additionally aggregate multiple database entries to keep the server data private as well.", "cite_spans": [], "ref_spans": [], "section": "Introduction"}, {"text": "We present a protocol for aggregated private information retrieval (APIR). In the use-case we will describe later, APIR would enable officials to get anonymous, aggregated information about movement records of Sars-Cov-2 patients. In the following, we first outline the main idea of our APIR protocol.", "cite_spans": [], "ref_spans": [], "section": "Aggregated Private Information Retrieval"}, {"text": "We assume without loss of generality that the first column of the database of the server consists of unique identifiers. The client's input to the protocol is a list of such ids, and the output is a vector representing the aggregated columns of the server's database with respect to the client's identifiers.", "cite_spans": [], "ref_spans": [], "section": "Aggregated Private Information Retrieval"}, {"text": "The threat model of the APIR protocol is similar to PIR protocols, i.e., the server should not know which elements were retrieved by the client. Additionally, in an APIR protocol, the client should also not be able to retrieve individual entries of the database, only receiving aggregated values is allowed. Note that the identifiers of the server are not considered to be private.", "cite_spans": [], "ref_spans": [], "section": "Aggregated Private Information Retrieval"}, {"text": "To achieve the privacy goals outlined above, we make heavy use of homomorphic encryption. In particular, the client homomorphically encrypts its identifiers before sending it to the server. Due to the nature of homomorphic encryption, the server can still perform the data aggregation. To prevent the client from learning individual entries, we make sure that the client's list of identifiers has a guaranteed minimum cardinality and that each identifier is unique. In addition, we apply differential privacy before releasing the output.", "cite_spans": [], "ref_spans": [], "section": "Aggregated Private Information Retrieval"}, {"text": "We report concrete benchmarks of our protocol for parameters suitable to create a Sars-Cov-2 hotspot map for small nations with millions of subscribers and tens of 1000s of base stations. In our concrete example this corresponds to an APIR protocol applied on a database consisting of \u2248 2 38 32-bit entries. We report multithreaded runtimes of 30 minutes for the standard APIR protocol, and 1 hour when extra steps are applied to ensure the input vector is not malicious. Our benchmarks show that it is feasible to use our APIR protocol on relatively large databases to support disease analysis of small nation states or large cities while still maintaining the privacy of infected people. We also show that costs for doing the same for larger nation states can still be expected to be very modest.", "cite_spans": [], "ref_spans": [], "section": "Benchmark results"}, {"text": "After introducing preliminaries in Section 2, we describe our APIR protocol more formally in Section 3. In Section 4, we illustrate an application of our APIR protocol, which can have a significant impact on the understanding where Sars-Cov-2 infection hotspots can be found. Afterward, in Section 5, we will have a look at the details of our implementation as well as the benchmarks.", "cite_spans": [], "ref_spans": [], "section": "Roadmap"}, {"text": "In this section, we cover the preliminaries required for the rest of the paper. We will first introduce the notations we use in the rest of the paper, before we describe homomorphic encryption, private information retrieval and differential privacy.", "cite_spans": [], "ref_spans": [], "section": "Preliminaries"}, {"text": "We follow the widespread convention to write vectors in bold lower case letters and matrices in upper case letters. We use x i to access the i-th element of vector x. For m \u2208 N and x \u2208 Z, let x m be defined as the vector of powers of x: x m = (x, x 1 , ..., x m ). We denote by c \u2022 d the element-wise multiplication (Hadamard product) of the vectors c and d. For a positive integer p, we identify Z p = Z \u2229 [\u2212p/2, p/2).", "cite_spans": [], "ref_spans": [], "section": "Notation"}, {"text": "The concept of homomorphic encryption (HE) has often been considered to be the holy grail in cryptography since it allows us to work on encrypted data without requiring the secret decryption key. It was first introduced by Rivest et al. [47] and partially HE schemes, i.e. schemes which allow performing a limited set of operations on encrypted data, have been known for years: The RSA [48] encryption scheme is homomorphic for multiplication and Paillier's cryptosystem [44] is homomorphic for addition. However, it was not until Gentry's groundbreaking work from 2009 [29] that we were able to construct the first fully homomorphic encryption (FHE) scheme, a scheme which in theory can evaluate an arbitrary circuit on encrypted data. His construction is based on ideal lattices and is deemed to be too impractical ever to be used, but it led the way to construct more efficient schemes in many following publications [12, 11, 28, 18, 19] .", "cite_spans": [{"start": 237, "end": 241, "text": "[47]", "ref_id": "BIBREF46"}, {"start": 386, "end": 390, "text": "[48]", "ref_id": "BIBREF47"}, {"start": 471, "end": 475, "text": "[44]", "ref_id": "BIBREF43"}, {"start": 570, "end": 574, "text": "[29]", "ref_id": "BIBREF28"}, {"start": 920, "end": 924, "text": "[12,", "ref_id": "BIBREF11"}, {"start": 925, "end": 928, "text": "11,", "ref_id": "BIBREF10"}, {"start": 929, "end": 932, "text": "28,", "ref_id": "BIBREF27"}, {"start": 933, "end": 936, "text": "18,", "ref_id": "BIBREF17"}, {"start": 937, "end": 940, "text": "19]", "ref_id": "BIBREF18"}], "ref_spans": [], "section": "Homomorphic Encryption"}, {"text": "Modern HE schemes are based on the learning with errors (LWE) [46] hardness assumption, and its variant over polynomial rings, the ring learning with error (RLWE) [42] hardness assumption. In the following, we recall one variant of the RLWE hardness assumption, the Decision-RLWE hardness assumption.", "cite_spans": [{"start": 62, "end": 66, "text": "[46]", "ref_id": "BIBREF45"}, {"start": 163, "end": 167, "text": "[42]", "ref_id": "BIBREF41"}], "ref_spans": [], "section": "Homomorphic Encryption"}, {"text": "Definition 1 (Decision-RLWE). For security parameter \u03bb, let f (x) be a cyclotomic polynomial \u03a6 m (x) with deg(f ) = \u03d5(m) depending on \u03bb and set R = Z[x]/(f (x)). Let q = q(\u03bb) \u2265 2 be an integer. For a random element s \u2208 R q and a distribution \u03c7 = \u03c7(\u03bb) over R, denote with A (q) s,\u03c7 the distribution obtained by choosing a uniformly random element a \u2190 R q and a noise term e \u2190 \u03c7 and outputting (a, [a \u00b7 s + e] q ). The Decision-RLWE d , q, \u03c7 problem is to distinguish between the distribution A (q) s,\u03c7 and the uniform distribution U (R 2 q ). The Decision-RLWE d , q, \u03c7 assumption is that the Decision-RLWE d , q, \u03c7 problem is infeasible.", "cite_spans": [], "ref_spans": [], "section": "Homomorphic Encryption"}, {"text": "During the encryption of a plaintext in RLWE based schemes, random noise is introduced into the ciphertext. This noise grows with the evaluation of homomorphic operations, negligible for addition, but significantly for homomorphic multiplication. Once this noise becomes too large and exceeds a threshold, the ciphertext cannot be decrypted correctly anymore. We call such a scheme a somewhat homomorphic encryption scheme (SHE), a scheme that allows evaluating an arbitrary circuit over encrypted data up to a certain depth. The specific depth depends on the choice of encryption parameters, and choosing parameters for larger depths comes, in general, with a considerable performance penalty.", "cite_spans": [], "ref_spans": [], "section": "Homomorphic Encryption"}, {"text": "In his work [29] , Gentry introduced the novel bootstrapping technique, a procedure that reduces the noise in a ciphertext and can turn a (bootstrappable) SHE scheme into an FHE scheme. However, this bootstrapping operation comes with high computational complexity. In many practical applications it is, therefore, faster to omit bootstrapping and choose a SHE scheme with large enough parameters to evaluate the desired circuit. In this work, we use the BFV [11, 28] SHE scheme to homomorphically encrypt the inputs of our protocol.", "cite_spans": [{"start": 12, "end": 16, "text": "[29]", "ref_id": "BIBREF28"}, {"start": 459, "end": 463, "text": "[11,", "ref_id": "BIBREF10"}, {"start": 464, "end": 467, "text": "28]", "ref_id": "BIBREF27"}], "ref_spans": [], "section": "Homomorphic Encryption"}, {"text": "We rely on HE instead of other privacy-preserving protocols, such as secure multi-party computation (MPC), due to several considerations:", "cite_spans": [], "ref_spans": [], "section": "Homomorphic Encryption"}, {"text": "-Homomorphic ciphertext-ciphertext multiplications are very costly in HE schemes, however, in our protocol we mainly rely on the cheaper plaintextciphertext multiplications. Therefore, all the operations involved in our protocol can be expressed relatively cheap using HE. -HE has the advantage of outsourcing computations. After the client sends the encrypted data to the server, the server can do the computations without further data exchange with the client. MPC protocols, in contrary, have a higher number of communication rounds and all parties have to participate in the computations. -MPC protocols usually have a higher communicational complexity, i.e., the amount of exchanged data is much higher. Especially over WAN networks, the communication alone can introduce significant delays.", "cite_spans": [], "ref_spans": [], "section": "Homomorphic Encryption"}, {"text": "In 1995, Chor et al. [20] introduced the notion of private information retrieval (PIR), server-client protocols which allow clients to hide queries to a database managed by one or many server, but still receive the correct elements. Thereby, the goal is to be more efficient than the straight-forward solution of letting the client download the whole database. In the literature we distinguish between two different types of PIR: information theoretic PIR (IT-PIR) [20, 4, 24, 25, 30] protocols which rely on multiple, non-colluding servers to ensure privacy; and computational PIR (CPIR) [43, 14, 26, 38, 40, 41, 52, 3] where a single server manages the database and encryption is used hide the query. Our approach is similar to the single-server CPIR variant, in which bestperforming CPIR protocols [43, 3] use homomorphic encryption to ensure that the server is still able to compute on the query to provide the final result. One major issue with CPIR protocols is that the server must process all entries of the database to answer a single query. If this would not be the case, the server must somehow have learned, which entries the client is not interested in, and thus, leaked information about the query. The computation cost of a server is, therefore, linear in the database size, which limits the practicability of CPIR to small databases. CPIR using homomorphic encryption boils down to essentially evaluate a vast vector-matrix multiplication on a one-hot encoded input vector. State-of-the-art CPIR implementation employs many optimizations to make retrieving single elements very feasible for limited database sizes. In this work, however, we are not interested in retrieving only one item; in fact, we want to ensure that single database entries are kept hidden from the client as well. We, therefore, employ homomorphic encryption to retrieve multiple aggregations of many database entries at once and invalidate responses for malicious queries. Furthermore, we want to implement use cases involving a huge database consisting of \u2248 2 38 32-bit entries.", "cite_spans": [{"start": 21, "end": 25, "text": "[20]", "ref_id": "BIBREF19"}, {"start": 465, "end": 469, "text": "[20,", "ref_id": "BIBREF19"}, {"start": 470, "end": 472, "text": "4,", "ref_id": "BIBREF3"}, {"start": 473, "end": 476, "text": "24,", "ref_id": "BIBREF23"}, {"start": 477, "end": 480, "text": "25,", "ref_id": "BIBREF24"}, {"start": 481, "end": 484, "text": "30]", "ref_id": "BIBREF29"}, {"start": 589, "end": 593, "text": "[43,", "ref_id": "BIBREF42"}, {"start": 594, "end": 597, "text": "14,", "ref_id": "BIBREF13"}, {"start": 598, "end": 601, "text": "26,", "ref_id": "BIBREF25"}, {"start": 602, "end": 605, "text": "38,", "ref_id": "BIBREF37"}, {"start": 606, "end": 609, "text": "40,", "ref_id": "BIBREF39"}, {"start": 610, "end": 613, "text": "41,", "ref_id": "BIBREF40"}, {"start": 614, "end": 617, "text": "52,", "ref_id": "BIBREF51"}, {"start": 618, "end": 620, "text": "3]", "ref_id": "BIBREF2"}, {"start": 801, "end": 805, "text": "[43,", "ref_id": "BIBREF42"}, {"start": 806, "end": 808, "text": "3]", "ref_id": "BIBREF2"}], "ref_spans": [], "section": "Private Information Retrieval"}, {"text": "Another thing to consider when designing a privacy-preserving data analytics protocol is that the result which the client obtains in plain can still leak information about the underlying dataset. In our case, an aggregated PIR protocol, the data aggregation can leak information about single database entries. We can use the well-established notion of differential privacy to help protect against such kind of information leakage. Let us recall the definition of -differential privacy [27] :", "cite_spans": [{"start": 485, "end": 489, "text": "[27]", "ref_id": "BIBREF26"}], "ref_spans": [], "section": "Differential Privacy"}, {"text": "Lemma 1 ( -Differential Privacy). A randomized mechanism A givesdifferential privacy if for any neighboring datasets D and D , and any S \u2208", "cite_spans": [], "ref_spans": [], "section": "Differential Privacy"}, {"text": "Since D and D are interchangeable, Lemma 1 implies:", "cite_spans": [], "ref_spans": [], "section": "Differential Privacy"}, {"text": "An established technique to achieve -differential privacy is the Laplace mechanism, i.e., to add Laplacian noise to the final result of the computation. The noise is, thereby, calibrated with the privacy budget and the global sensitivity \u2206q of the computation q: \u2206q = max D,D ||q(D) \u2212 q(D )|| for all neighboring D and D . In other words, the global sensitivity represents the maximum possible value of each element in the dataset. The Laplace distribution for a scale factor b is given as Lap(x|b) = 1 2b e \u2212 |x| b , in the Laplace mechanism a scale factor of b = \u2206q is used.", "cite_spans": [], "ref_spans": [], "section": "Differential Privacy"}, {"text": "We can apply differential privacy to our APIR protocol by adding Laplacian noise to each element of the final result of the matrix multiplication v T \u00b7 Z:", "cite_spans": [], "ref_spans": [], "section": "Differential Privacy"}, {"text": "We note that in general, each column of the matrix multiplication can represent a different dataset with a different sensitivity \u2206q i . However, in the use case we describe in our work, each \u2206q i is equal.", "cite_spans": [], "ref_spans": [], "section": "Differential Privacy"}, {"text": "In Section 3.1, we give a high-level description of our protocol below. A formal definition of the protocol is provided in Figure 1 . In addition, we illustrate our protocol in Figure 2 including an interactive proof to protect against malicious queries described later in this section. Then we discuss in Section 3.5 the concrete privacy and a generalization of our APIR protocol in Section 3.6.", "cite_spans": [], "ref_spans": [{"start": 123, "end": 131, "text": "Figure 1", "ref_id": "FIGREF1"}, {"start": 177, "end": 185, "text": "Figure 2", "ref_id": null}], "section": "APIR"}, {"text": "We use a HE scheme HE = (HE.KGen, HE.Enc, HE.Dec, HE.Eval). Before executing the protocol, the client runs KGen to obtain an evaluation key evk and a private key sk. We assume that the server knows evk before running the protocol.", "cite_spans": [], "ref_spans": [], "section": "Protocol"}, {"text": "First, observe that according to our assumptions, the server is allowed to share the identifiers with the client. We can exploit this fact by server not only sending the identifiers but also the indices of the identifiers in the database. In this case, the client not only gets to know which identifiers it has in common with the server but also their exact location in the database of server. This information is stored in the vector v = v 1 \u00b7 \u00b7 \u00b7 v N . Sending v to the server would stand in contradiction to our threat model because the server would directly learn the identifiers of the client. Therefore, the client homomorphically encrypts the vector v before sending it to the server. The server can not learn anything from the encrypted vector provided that the HE scheme is semantically secure.", "cite_spans": [], "ref_spans": [], "section": "Protocol"}, {"text": "Remark. In some applications the list of identifiers in the server database might also be considered private information. In such cases, one can augment this step by using a variant of Private Set Intersection (PSI) with associated data transfer. In particular, the labeled PSI protocol in [17] provides the required features while conveniently being based on Fully Homomorphic Encryption.", "cite_spans": [{"start": 290, "end": 294, "text": "[17]", "ref_id": "BIBREF16"}], "ref_spans": [], "section": "Protocol"}, {"text": "Public inputs: Client and server agree on parameters N, n, W, s \u2208 N, \u2208 R>0. Private inputs: The client has input (x1, . . . , x\u03bd ) \u2208 {0, 1} n\u00d7\u03bd with \u03bd \u2208 N, and keys (evk, sk) for a homomorphic encryption scheme. The server has input (y1, . . . , yN ) \u2208 {0, 1} n\u00d7N , Z = (zij) \u2208 Z N \u00d7k with k \u2208 N and knows evk. ", "cite_spans": [], "ref_spans": [], "section": "Protocol"}, {"text": "and sends \u00b5 = \u00b51 \u00b7 \u00b7 \u00b7 \u00b5s 0 \u00b7 \u00b7 \u00b7 0 T \u2208 Z k p to the client Else:", "cite_spans": [], "ref_spans": [], "section": "Protocol"}, {"text": "Server chooses r $ \u2190 Z k p , and computes", "cite_spans": [], "ref_spans": [], "section": "Protocol"}, {"text": "5. If interactive == TRUE: Client decrypts \u03c1 \u2190 HE.Decsk(\u00b5), and sends \u03c1 to the server. 6. If interactive == TRUE:", "cite_spans": [], "ref_spans": [], "section": "Protocol"}, {"text": "If \u03c1 = \u03c1 = \u03c11 \u00b7 \u00b7 \u00b7 \u03c1s 0 \u00b7 \u00b7 \u00b7 0 T server aborts, otherwise server sets \u00b5 \u2190 0. As mentioned before, we want to ensure that the client does not get the values of individual rows. Therefore, the server checks that the hamming weight of c is not too low. Depending on the specific use of the protocol, the threshold W can vary. This precaution alone is not enough against a malicious client who could also send an arbitrary non-binary vector. As an example, by sending a vector of all zeros except one coordinate equal to the minimum hamming weight W , the client would still learn the values of this particular row. To prevent such abuse, the server also checks that the vector c is binary. Only if both conditions are satisfied, the following data aggregation is valid. Technically, we developed two variants of how the server can check the correctness of the query vector v.", "cite_spans": [], "ref_spans": [], "section": "Protocol"}, {"text": "One can detect a malicious client before doing the costly matrix multiplication by introducing one additional round of communication, the other invalidates the result of our APIR protocol for malicious queries. For details see Section 3.3 and Section 3.4.", "cite_spans": [], "ref_spans": [], "section": "Sever computes"}, {"text": "The data aggregation is done by computing a large matrix multiplication. The vector c contains the information, which rows should part of the sum. Since c is encrypted, according to the security guarantees of the HE scheme it does not reveal any information to the server, however, by using Eval and evk, the server can still perform the matrix multiplication. We add a small random noise to the result of the homomorphic matrix multiplication for privacy reasons (see Section 2.4). By decrypting h * with its private key sk, the client gets the final output of the protocol.", "cite_spans": [], "ref_spans": [], "section": "Sever computes"}, {"text": "One assumption of the protocol is that it requires the input vector to be binary. If this is not the case, the client can arbitrarily modify the contribution of a single person to the overall aggregated result, which can leak private information. Since the server only receives an encryption of the input vector, simply checking for binary values is not an option. However, we can use similar techniques to the ones used in Bulletproofs [13] to provide assurance that the query vector c is made up of binary elements, i.e., \u2200i : c i \u2208 {0, 1}.", "cite_spans": [{"start": 437, "end": 441, "text": "[13]", "ref_id": "BIBREF12"}], "ref_spans": [], "section": "Proving that the Query Vector is Binary"}, {"text": "Lemma 2. Let c \u2208 Z N be the query vector and let d = c \u2212 1. If the following condition holds, c is a binary vector c \u2208 Z N 2 :", "cite_spans": [], "ref_spans": [], "section": "Proving that the Query Vector is Binary"}, {"text": "Note in our scenario, d can be computed by the server. However, the server needs to compare a homomorphically encrypted vector to zero to check Lemma 2, which is not trivially possible. Therefore, we want to encode this comparison as a mask \u00b5 bin \u2208 Z k p , which will either be zero if c \u2208 Z N 2 , random otherwise. Adding \u00b5 bin to the response of the server will invalidate the result for malicious input vectors, but do not affect correct queries.", "cite_spans": [], "ref_spans": [], "section": "Proving that the Query Vector is Binary"}, {"text": "The result of c \u2022 d can be aggregated into a single value by calculating the inner product c, d , which will again be zero if c \u2208 Z N 2 . The server then adds a random value y $ \u2190 Z p to reduce the probability for the client to cheat by letting several entries of c cancel each other out during the inner product. A final randomization with a vector r $ \u2190 Z k p , produces the final mask:", "cite_spans": [], "ref_spans": [], "section": "Proving that the Query Vector is Binary"}, {"text": "For the generic case of a vector b and a randomly chosen y, b, y N = 0 will hold for a b = 0 only with probability N/p [13] . Using a 60 bit prime, i.e. p \u2248 2 60 , for N = 2 23 , this probability is P r \u2248 2 23 2 60 = 2 \u221237 , i.e. a soundness error of 37 bits. ", "cite_spans": [{"start": 119, "end": 123, "text": "[13]", "ref_id": "BIBREF12"}, {"start": 207, "end": 209, "text": "23", "ref_id": "BIBREF22"}], "ref_spans": [], "section": "Proving that the Query Vector is Binary"}, {"text": "For i = 1 to N : For i = 1 to N :", "cite_spans": [], "ref_spans": [], "section": "Plain Phase"}, {"text": "For i = 1 to N :", "cite_spans": [], "ref_spans": [], "section": "Check Query Vector"}, {"text": "For j = 1 to k:", "cite_spans": [], "ref_spans": [], "section": "Differential Privacy"}, {"text": "For j = 1 to k: For j = 1 to k:", "cite_spans": [], "ref_spans": [], "section": "Decryption Phase"}, {"text": "Output h1 h2 \u00b7 \u00b7 \u00b7 hk Fig. 2 : Illustration of our APIR protocol with interactive proof for an honest query vector.", "cite_spans": [], "ref_spans": [{"start": 22, "end": 28, "text": "Fig. 2", "ref_id": null}], "section": "Decryption Phase"}, {"text": "Another problem of our protocol is that the client can target the values of single people by querying the server with an input vector of hamming weight W = 1. Again, since the query is encrypted, the server can not trivially check the hamming weight of the input vector. However, we can apply similar techniques as in the previous section to incorporate a hamming weight check into a masking value. Again let c be the query vector and let W be its announced hamming weight. On the server-side, calculate c, 1 N , which is equal to the hamming weight of c. Therefore, with a random vector r $ \u2190 Z k p , the following mask \u00b5 HW \u2208 Z k p is zero if c has the announced hamming weight W , random otherwise:", "cite_spans": [], "ref_spans": [], "section": "Proving the Hamming Weight of the Query Vector"}, {"text": "We then combine the two separate proofs in equation 3 and equation 4 into a combined masking value \u00b5, adding a random value z $ \u2190 Z p to avoid the separate masks canceling each other out:", "cite_spans": [], "ref_spans": [], "section": "Proving the Hamming Weight of the Query Vector"}, {"text": "\u00b5 is now equal to 0 k if c is a binary vector with hamming weight W , random otherwise. A vector c not fulfilling these conditions will result in a masking value of 0 k only with probability N +1 p .", "cite_spans": [], "ref_spans": [], "section": "Proving the Hamming Weight of the Query Vector"}, {"text": "The masks calculated in the previous section is finally added to the result of the matrix multiplication to invalidate the result for malicious queries. However, one could also perform an additional round of interaction between the client and the server as follows: Calculate a challenge value like the previous mask, however, instead of using a random vector r $ \u2190 Z k p , we multiply the mask with a random scalar r $ \u2190 Z p and also add a final random value \u03c1 $ \u2190 Z p :", "cite_spans": [], "ref_spans": [], "section": "Interaction vs. Masking"}, {"text": "The server then sends this ciphertext as a challenge to the client, who decrypts it and sends back the result. Only if the sent value is equal to \u03c1, the matrix multiplication is carried out and the result is sent back to the client. This approach has multiple advantages: First, at the cost of one more round of interaction and the associated communication, the server can detect malicious input vectors before carrying out the expensive matrix multiplication. Furthermore, this approach can also be repeated in parallel to boost the soundness.", "cite_spans": [], "ref_spans": [], "section": "Interaction vs. Masking"}, {"text": "With a soundness error of N +1 p , repeating the challenge t times reduces the probability to cheat to N +1 p t . Therefore, we require at least s challenges in parallel to achieve a soundness error of at least the security level \u03bb (in bits), with s being:", "cite_spans": [], "ref_spans": [], "section": "Interaction vs. Masking"}, {"text": "For the privacy of APIR, the selection of parameters is of outermost importance. By using the APIR protocol in an application, the parameters n, k, and N get fixed by the specific data sets, whereas the parameters and W can be freely chosen. The concrete privacy -in particular for the items in the client's database -is highly dependent on those two parameters. An anonymization expert should choose them with knowledge of the specific data sets and the actual application.", "cite_spans": [], "ref_spans": [], "section": "Privacy"}, {"text": "The aim here is that the parameters are selected in a way that, from the output, no re-identification is possible but correctness and usefulness of the aggregated results is maintained.", "cite_spans": [], "ref_spans": [], "section": "Privacy"}, {"text": "The data aggregation of our APIR protocol is presented in a straightforward fashion. We use the simplest form of aggregations; namely, just adding all the information requested from the client, which corresponds to a single big matrix multiplication. Depending on the use-case, one could think of more involved methods. The computation on the server-side can consist of any combination of (matrix) multiplications, (matrix) additions as well as rotations of single rows or columns. In this light, APIR can be seen not only as a protocol but rather as a useful framework for privacy-preserving data analytics.", "cite_spans": [], "ref_spans": [], "section": "Generalized View of APIR"}, {"text": "Our APIR protocol can help to learn more about the behavioral patterns of people tested positive with Sars-CoV-2. Note that the whole objective of our approach is to gather this information without violating the privacy of patients or enabling the tracking of individuals. In this section, we describe how the generic protocol in Figure 1 can be used to create a private heat map of Sars-CoV-2 positive people at the time of their infection. Such a heat map could lead to a better understanding of Sars-CoV-2 hotspots, i.e., places where there is a significantly higher risk of getting infected with Sars-CoV-2. This, in turn, could be valuable knowledge in the further containment of Sars-CoV-2.", "cite_spans": [], "ref_spans": [{"start": 330, "end": 338, "text": "Figure 1", "ref_id": "FIGREF1"}], "section": "Application: National Scale Sars-CoV-2 Heat Map"}, {"text": "The parties involved in creating a Sars-CoV-2 heat map are a mobile network operator (M ) and a health authority (H). An illustration of this application can be found in Figure 3 . M takes the role of the server, where the identifiers are mobile phone numbers. Let N be the number of all mobile phone numbers registered by M and n the length to represent a mobile phone number. The matrix Z contains location data. More precisely, each row is the location data for one particular mobile phone number. For simplification, we assume that the location data is represented as follows. The value z ij is the amount of time spent by person i in the cell site j. Therefore, k is the number of cell towers operated by M . On the other side, the role of the client is taken by H. The input of H is a list of \u03bd mobile phone numbers of Sars-CoV-2 patients. The output of the protocol is a vector h 1 \u00b7 \u00b7 \u00b7 h k , where h j is the total amount of time spent by all the Sars-CoV-2 patients in the cell site j.", "cite_spans": [], "ref_spans": [{"start": 170, "end": 178, "text": "Figure 3", "ref_id": "FIGREF3"}], "section": "Heat Map Protocol"}, {"text": "Note that, as we have already mentioned in Section 3.6, our APIR protocol should be seen more as a framework. This means that with little adaptation, our APIR protocol can be used for many different analytical methods. In particular, we can exchange the data aggregation (matrix multiplication) by different computations to support a larger class of epidemiologically useful statistics. The heat map is only one concrete instantiation of this framework.", "cite_spans": [], "ref_spans": [], "section": "Heat Map Protocol"}, {"text": "We now want to have a look at the privacy features of the application inherited from them generic protocol. Recall, the generic protocol has two checks to ensure that H does not learn the values of any row, i.e., H should not learn the movement pattern of any individual. More concretely, H is not allowed to query the location data for less than W different people. W has to be chosen in such a way that the data aggregation provides anonymity and its exact value will highly depend on the actual underlying data, which is the reason why we do not give a generic value in this paper. We urge users of our protocol to rely on an expert in the field of de-anonymization with sufficient knowledge of location data to choose a suitable value. To sum up, by using our protocol correctly, highly sensitive personal data is protected. In particular, M does not learn which people are infected by Sars-CoV-2. On the other side, H does not get the movement record of individual patients. ", "cite_spans": [], "ref_spans": [], "section": "Heat Map Protocol"}, {"text": "Preprocessing. A preprocessing phase on the side of the mobile network provider could increase the value of the heat map as well as provide even more privacy. First, M could try to find the place of residence by assuming people sleep at home. Therefore, they can look at the location of people at night and remove those places for the heat map creation. Once M has completed this step, the heat map will additionally be more informative in the sense of H getting a better picture, which public places might bear a high risk of getting infected with Sars-CoV-2. Secondly, to further enhance the privacy of patients, M should filter out isolated profiles. Such filtering of the data obviously does not affect the meaningfulness of the heat map, since crowded public places would not be affected. Note that both preprocessing steps are done on the side of the mobile network operator. That means those steps can be done on non-encrypted data and therefore are negligible when it comes to the runtime of our protocol.", "cite_spans": [], "ref_spans": [], "section": "Practical Considerations"}, {"text": "Applying Differential Privacy. An attack vector for H in our protocol can be to abuse the heatmap to track individual people by querying for isolated profiles. For example, they want to query for a person living in the westmost area of the country. To overcome the hamming weight check on the server-side, they additionally query for W \u2212 1 people living on the east side of the country. The location data of the targeted person is clearly shown on the resulting heatmap; H just has to look at the western part of the result. Applying differential privacy with suitable parameters will protect against such an attack since the overall goal of differential privacy is to decrease the statistical dependence of the final result to a single database entry as much as possible. In our use-case, therefore, differential privacy achieves that it is infeasible to distinguish between heatmaps, in which we include a single person in the accumulation and heatmaps in which we do not.", "cite_spans": [], "ref_spans": [], "section": "Practical Considerations"}, {"text": "A general issue of differential privacy is that the privacy guarantees get weaker the more queries the client is allowed to do. This, however, is no issue in our use case, since the location data changes every couple of days, and we can limit H to query a heatmap to, e.g., once a day.", "cite_spans": [], "ref_spans": [], "section": "Practical Considerations"}, {"text": "Choosing proper parameters, however, highly depends on the underlying dataset. On the one hand, the chosen should be small enough to satisfy privacy concerns; on the other hand, it should be big enough not to overflow the result with noise. In our protocol, accumulations of a sufficient amount of people should not be affected by the noise, i.e., the noise on its own should not be able to create hotspots. Again, we urge users of our protocol to rely on an expert in the field of de-anonymization with sufficient knowledge of location data to choose suitable values for the application of differential privacy.", "cite_spans": [], "ref_spans": [], "section": "Practical Considerations"}, {"text": "is an actively developed open-source library maintained by Microsoft Research compatible with all major operating systems, including Windows, Linux, and OS X.", "cite_spans": [], "ref_spans": [], "section": "Practical Considerations"}, {"text": "The computationally most expensive phase in the protocol is the Data Aggregation phase, in which the server multiplies a huge matrix to a homomorphically encrypted input vector. Therefore, the main objective of our implementation is to perform this huge matrix multiplication as efficiently as possible.", "cite_spans": [], "ref_spans": [], "section": "Practical Considerations"}, {"text": "Modern HE schemes allow for packing a vector of n plaintexts into only one ciphertext. Performing an operation on this ciphertext then is implicitly applied to each slot of the encrypted vector, similar to single-instruction-multiple-data (SIMD) instructions on modern CPU's (AVX, SSE2, etc.). However, the size of the ciphertext does not depend on the exact number (\u2264 n) of plaintexts encoded. The HE schemes support a variety of SIMD operations, including slotwise addition, subtraction and multiplication, and slot-rotation. However, one can not directly access a specific slot of the encoded vector. We can use the SIMD encoding to speed up the matrix multiplication of our protocol significantly.", "cite_spans": [], "ref_spans": [], "section": "Packing"}, {"text": "In the BFV scheme (and its implementation in the SEAL library), the number of available SIMD slots is equal to the degree of the cyclotomic reduction polynomial (x n + 1); thus, it is always a power of two. In the ciphertexts, the n slots are arranged as matrix of dimensions (2 \u00d7 n/2). A ciphertext rotation affects either all rows, or all columns of the matrix simultaneously. Therefore, we can think of the inner matrix as two rotatable vectors, which can be swapped. Figure 4 highlights the inner structure of the ciphertext and the rotation operations.", "cite_spans": [], "ref_spans": [{"start": 471, "end": 479, "text": "Figure 4", "ref_id": "FIGREF5"}], "section": "Packing"}, {"text": "The SIMD encoding can be used to efficiently speed up matrix multiplication by using the diagonal method introduced by Halevi and Shoup in [32] . They have shown that a matrix-vector multiplication of a matrix Z \u2208 Z m\u00d7m and vector v \u2208 Z m can be expressed by m elementwise vector-vector multiplications, m \u2212 1 rotations, and m \u2212 1 additions, operations that can easily be evaluated in an HE scheme: \u00b7 \u00b7 \u00b7 n \u2212 1 n by applying the baby-step giant-step algorithm [33, 34] :", "cite_spans": [{"start": 139, "end": 143, "text": "[32]", "ref_id": "BIBREF31"}, {"start": 460, "end": 464, "text": "[33,", "ref_id": "BIBREF32"}, {"start": 465, "end": 468, "text": "34]", "ref_id": "BIBREF33"}], "ref_spans": [], "section": "Baby-Step Giant-Step Matrix Multiplication"}, {"text": "where m = m 1 \u00b7m 2 and diag (Z, i) = rot (diag(Z, i), \u2212 i/m 1 \u00b7 m 1 ). 6 Note, that rot(v, j) only has to be computed once for each j < m 1 , therefore, equation 9 only requires m 1 + m 2 \u2212 2 rotations of the vector v in total.", "cite_spans": [{"start": 71, "end": 72, "text": "6", "ref_id": "BIBREF5"}], "ref_spans": [], "section": "Baby-Step Giant-Step Matrix Multiplication"}, {"text": "Trivially, we can use the following equation to implement a v T \u00b7 Z multiplication, like we use in our protocol:", "cite_spans": [], "ref_spans": [], "section": "Baby-Step Giant-Step Matrix Multiplication"}, {"text": "In our protocol we want to homomorphically evaluate v T \u00b7 Z, where v \u2208 {0, 1} N and Z \u2208 Z N \u00d7k p , for big parameters N and k. As described in Section 5.1, the inner structure of the BFV ciphertext consists of two vectors of size n/2 each, and it does not allow a cyclic rotation over the whole input vector of size n. However, a rotation over the whole input vector is required by the baby-step giant-step algorithm. Therefore, we only can perform a baby-step giant-step multiplication with a (n/2 \u00d7 n/2) matrix using this packing. Fortunately, we can use the remaining n/2 slots (i.e., the second vector in the inner structure of the BFV ciphertext) to perform a second (n/2 \u00d7 n/2) matrix multiplication simultaneously. Therefore, after a homomorphic baby-step giant-step matrix multiplication, the result is a ciphertext, where each of the two inner vectors encodes the result of a (1 \u00d7 n/2) \u00d7 (n/2 \u00d7 n/2) vector-matrix multiplication. The sum of those two vectors can easily be obtained by rotating the columns of the ciphertext and adding it to the first result:", "cite_spans": [], "ref_spans": [], "section": "Homomorphic N \u00d7 k Matrix Multiplication"}, {"text": "Thus, we can use one (n/2 \u00d7 n/2) baby-step giant-step matrix multiplication and equation 11 to implement a homomorphic (1 \u00d7 n) \u00d7 (n \u00d7 n/2) = (1 \u00d7 n/2) vector-matrix multiplication. Taking this into account, we split the huge (N \u00d7 k) matrix into n v \u00b7 n o submatrices of size (n \u00d7 n/2), with n v = N n and n o = 2k n , padding the submatrices with zeros if necessary. We split the input vector v into n v vectors of size n (padding the last vector with zeros if necessary) and encrypt each of these vectors to get n v ciphertexts c i . The final result of the v T \u00b7 Z matrix multiplication can be computed with the following equation:", "cite_spans": [], "ref_spans": [], "section": "Homomorphic N \u00d7 k Matrix Multiplication"}, {"text": "where, SubMat(M, j, i) returns the submatrix of Z with size (n\u00d7n/2), starting at row n\u00b7j and column n 2 \u00b7i, and MatMul(Z, c) performs the homomorphic baby-step giant-step matrix multiplication Z \u00b7 c followed by equation 11. Equation 12 produces n o ciphertextsc i , with the final results being located in the first n/2 slots of the ciphertexts. Overall, our algorithm to homomorphically calculate v T \u00b7 Z requires n v \u00b7 n o baby-step giant-step matrix multiplications and the total multiplicative depth is 1 plaintext-ciphertext multiplication.", "cite_spans": [], "ref_spans": [], "section": "Homomorphic N \u00d7 k Matrix Multiplication"}, {"text": "To calculate the masking value (equation 5), or the challenge (equation 6), we need to calculate the inner product of two homomorphically encrypted ciphertexts c and d. After an initial multiplication c \u00b7 d, the inner product requires log 2 (n/2) rotations and addition, followed by equation 11 to produce a ciphertext, where the result is encoded in each of the n slots.", "cite_spans": [], "ref_spans": [], "section": "Homomorphic Evaluation of the Masking Value"}, {"text": "Our implementation uses rejection sampling and the SHAKE128 algorithm to cryptographically secure sample all the required random values in Z p . The total multiplicative depth to homomorphically evaluate the final mask (equation 5 or equation 6) is 1 ciphertext-ciphertext multiplication and 2 plaintext-ciphertext multiplications.", "cite_spans": [], "ref_spans": [], "section": "Homomorphic Evaluation of the Masking Value"}, {"text": "If we want to boost soundness in the interactive version of the challenge mask, we can encode multiple values of different \u00b5 chal into the SIMD slots of one ciphertext, filling the remaining slots with zeros: \u00b5 = (\u00b5 chal,0 , . . . , \u00b5 chal,s\u22121 , 0, . . . , 0)", "cite_spans": [], "ref_spans": [], "section": "Homomorphic Evaluation of the Masking Value"}, {"text": "We can evaluate equation 13 by multiplying a vector r = (r i , 0, . . . , 0) instead of a scalar r in equation 6 to get \u00b5 chal,i and add rotations of those individual masks:", "cite_spans": [], "ref_spans": [], "section": "Homomorphic Evaluation of the Masking Value"}, {"text": "In BFV, one can choose three different parameters which greatly impact the runtime and the available noise budget (i.e. how much further noise can be introduced until decryption will fail):", "cite_spans": [], "ref_spans": [], "section": "BFV Parameters"}, {"text": "-Plaintext modulus p: p defines the Ring Z p to which the homomorphic operations correspond to. Every result encoded in the ciphertext vector will be an element of Z p . Therefore, one has to make sure that p is big enough, such that no computation overflows. On the other hand, a big p has a bad impact on the ciphertext noise, where the noise cost of homomorphic operations is higher for bigger p. Additionally, the size of p will also affect the runtime of homomorphic operations. In general, SEAL allows arbitrary plaintext moduli t \u2265 2 \u2208 Z; however, if we want to enable SIMD-packing (Section 5.1), then the plaintext modulus has to be a prime p and congruent to 1 (mod 2n). -Ciphertext modulus q: q defines the available noise budget. Therefore, a bigger q allows for a bigger depth in homomorphic operations. However, bigger q's have an adverse effect on the security of the encryption scheme. Additionally, q also influences the runtime of homomorphic operations; more specifically, the number of primes q is composed of. The more primes, the longer the computation times.", "cite_spans": [], "ref_spans": [], "section": "BFV Parameters"}, {"text": "-Degree n of the reduction polynomial: In BFV in SEAL n is always a power of two and has a direct impact on the runtime of the scheme. A bigger n drastically increases the time a homomorphic operation needs for evaluation. On the other hand, a bigger n also increases the security of the scheme and, therefore, allows for a bigger ciphertext modulus q to increase the noise budget.", "cite_spans": [], "ref_spans": [], "section": "BFV Parameters"}, {"text": "We test our implementation for a security level of \u03bb = 128 bit and \u03bb = 80 bit. We use the LWE estimator [2] by Albrecht et al. to find suitable BFV parameters which provide 80 bit security against known attacks; for 128 bit security SEAL already provides parameters for different reduction polynomial degrees n. See Appendix A for more details on the used parameters.", "cite_spans": [{"start": 104, "end": 107, "text": "[2]", "ref_id": "BIBREF1"}], "ref_spans": [], "section": "BFV Parameters"}, {"text": "Multithreading. Since in our use cases N is much bigger than k, we implemented multithreading, such that the threads split the number of rows in the matrix (more specifically, the number of submatrices in the rows n v ) equally amongst all available threads. Therefore, each thread has to perform at most nv #threads \u00b7 n o MatMul evaluations, which will be combined at the end by summing up the intermediate results. In case we want to add the mask to the result, an extra thread will perform the mask-evaluation in parallel to the matrix multiplication. In the other case, the case of the interactive challenge round, we leverage multithreading, such that we distribute the computation of the masks \u00b5 bin equally amongst all available threads, i.e., at most s #threads evaluations of \u00b5 bin per thread. In parallel, an additional thread performs the evaluation of \u00b5 HW before the results are combined with new random values z and r for each slot of the final mask.", "cite_spans": [], "ref_spans": [], "section": "Benchmarks"}, {"text": "Benchmark Platform. Our implementation 7 is compatible to Linux and Windows; however, we ran our benchmarks on a Linux cluster with two Intel Xeon E5-2699 v4 CPU's (total of 44 cores @ 2.2 GHz, 88 threads) and 512 GB RAM available.", "cite_spans": [], "ref_spans": [], "section": "Benchmarks"}, {"text": "Runtime. The runtime of our protocol is O(n v n o ), i.e., it scales linearly in the number of MatMul evaluations. This can be seen in Table 1 in which we summarize the runtime of the homomorphic matrix multiplication for different matrix dimensions using only one thread. For better comparability, we evaluate the different sizes with the same BFV parameter set. For real-world matrix dimensions, some added runtime has to be expected due to thread synchronization and the accumulation of the intermediate thread results. Real World Matrix Dimension. At the time of writing, approximately 8.9 million people live in Austria 8 and the total number of cell cites is 18389 9 (June 2019). In our benchmarks, we want to capture the Austrian use case and set the matrix dimensions to N = 2 23 and k = 2 15 . In Table 2 we list the runtime for a homomorphic (1 \u00d7 2 23 ) \u00d7 (2 23 \u00d7 2 15 ) matrix multiplication, for different BFV parameters, using 88 threads. We also provide the total number of MatMul evaluations and the (maximum) number of evaluations per thread. Additionally, we give performance results for parameters also capable of evaluating the masking value. As Table 2 shows, a matrix multiplication takes approximately 1 hour for a 33 bit plaintext modulus with 128 bit security and 1.5 hour for the bigger 60 bit modulus. The noise budget for n = 8192 and a 60 bit modulus, however, is not sufficient to evaluate the masking value, which has a bigger multiplicative depth than the matrix multiplication. Increasing n leads to a performance drop, more specifically, the evaluation with a 60 bit plaintext modulus takes 4.5 hours.", "cite_spans": [{"start": 798, "end": 800, "text": "15", "ref_id": "BIBREF14"}], "ref_spans": [{"start": 135, "end": 142, "text": "Table 1", "ref_id": "TABREF2"}, {"start": 806, "end": 813, "text": "Table 2", "ref_id": "TABREF3"}, {"start": 1165, "end": 1172, "text": "Table 2", "ref_id": "TABREF3"}], "section": "Benchmarks"}, {"text": "Reducing the security level to \u03bb = 80 bit allows us to use a smaller n for the evaluation of the mask with a 60 bit prime, and the matrix multiplication with a 33 bit plaintext modulus, splitting the respective runtimes in half. Unfortunately, n can not be reduced for the 33 bit prime with 80 bit security when masking is applied, increasing the runtime of the matrix multiplication compared to the 128 bit security case. This is due to the fact that in the 80 bit security case q is composed of more distinct primes q i . We recommend, therefore, to always use 128 bit security parameters for the 33 bit prime when the masking value has to be evaluated.", "cite_spans": [], "ref_spans": [], "section": "Benchmarks"}, {"text": "Data Transmission. In Table 3 , we list the sizes of all the data, which has to be transmitted between the server and the client. Each row corresponds to a different parameter set from Table 2 . The sizes were obtained by storing each of the described elements on the file system on the cluster. The table lists the size of the ciphertexts (ct), Galois keys (gk), and relinearization keys (rk). Galois keys are required to perform homomorphic rotations, each rotation index requires one Galois key, plus an additional key for rotating the columns. When using the babystep giant-step algorithm, we need a key for the index 1 to calculate rot(v, j), and a key for the indices k \u00b7 m 1 , \u22000 < k < m 2 . Furthermore, when masking is applied, we need the keys for the power-of-2 indices to calculate the inner product of two ciphertexts. The relinearization key is required to linearize the result of a ciphertext-ciphertext multiplication. Since we only have to perform such a multiplication when we calculate the masking values, we can omit to send the relinearization key when the mask is not applied.", "cite_spans": [], "ref_spans": [{"start": 22, "end": 29, "text": "Table 3", "ref_id": "TABREF4"}, {"start": 185, "end": 192, "text": "Table 2", "ref_id": "TABREF3"}], "section": "Benchmarks"}, {"text": "In addition to the values described in Table 3 , the client has to announce the used BFV parameters and the hamming weight of the input vector. These values have a combined size of less than 300 bytes.", "cite_spans": [], "ref_spans": [{"start": 39, "end": 46, "text": "Table 3", "ref_id": "TABREF4"}], "section": "Benchmarks"}, {"text": "As Table 3 shows, client-to-server communication is significantly more extensive than the response of the server. The main parts of the communication are the initial ciphertexts; however, especially when masking has to be applied, the Galois keys have a significant size as well. The plaintext modulus p has little to no effect on the number of bytes, contrary to the reduction polynomial degree n, which influences the communication cost significantly. The response of the server is very small in comparison to the ciphertexts he receives from the client. One reason for that is the small parameter k compared to N . The other reason is, that our implementation performs a so-called modulus-switch to level 0 after the computation, reducing the ciphertext modulus q to only one of the moduli q i it is composed of. Challenge Mask Compuation Time. In Table 4 , we list the runtime of the evaluation of the interactive challenge mask for different BFV parameters with a soundness error of at least \u03bb bits. As Table 4 shows, the evaluation of the challenge mask is significantly faster than performing the matrix multiplication, allowing the server to detect and filter malicious inputs before engaging in the costly matrix evaluation. As we already stated, calculating the masking value for a 33 bit prime is slower with parameters for 80 bit security than with parameters for 128 bit security (given multithreading with enough threads) since q is composed of more primes q i and n stays the same for both parameter sets. We note that we require additional s Galois keys for performing the challenge mask creation, increasing the communicated bytes. However, the additional keys require a comparably small amount of data, e.g., less than 25 MiB for entry nr. 3 in Table 3 .", "cite_spans": [], "ref_spans": [{"start": 3, "end": 10, "text": "Table 3", "ref_id": "TABREF4"}, {"start": 851, "end": 858, "text": "Table 4", "ref_id": "TABREF5"}, {"start": 1008, "end": 1015, "text": "Table 4", "ref_id": "TABREF5"}, {"start": 1763, "end": 1770, "text": "Table 3", "ref_id": "TABREF4"}], "section": "Benchmarks"}, {"text": "In this section, we want to give an estimate of the costs of deploying our system to create a corona heatmap for a larger country, more specifically, for Germany.", "cite_spans": [], "ref_spans": [], "section": "Price Estimation for Deployment in Germany"}, {"text": "At the time of writing, about 83.1 million people live in Germany 10 , and a total of 74280 cell sites are deployed 11 . With the BFV parameters of entry Nr. 1 in Table 2 , i.e., n = 8192, this corresponds to a total number of of n v \u00b7 n o = 192755 MatMul evaluations. To get 96 MatMul evaluations per thread, we would have to acquire 21 CPU's capable of handling 96 threads each. To get a estimate for doing such computations used current market prizes 12 the cost of one CPU capable of handling 96 threads is \u223c 1.5 $ per hour. Taking an additional overhead by handling so many threads and combining intermediate results, we estimate the cost of evaluating the homomorphic matrix multiplication for the German use case using AWS to \u223c 60 $. While noting that a trivial outsourcing of such computations is not part of our proposal, this estimate still shows that it is likely very feasible to create a heatmap once a day to gain valuable insight into the spread of the disease, even for larger countries.", "cite_spans": [{"start": 116, "end": 118, "text": "11", "ref_id": "BIBREF10"}], "ref_spans": [{"start": 163, "end": 170, "text": "Table 2", "ref_id": "TABREF3"}], "section": "Price Estimation for Deployment in Germany"}, {"text": "Our protocol shows that concrete privacy-preserving data analytics is possible even on a national scale.", "cite_spans": [], "ref_spans": [], "section": "Concluding discussion"}, {"text": "For an interested audience with little security and cryptography background, we created a webpage 13 that describes our approach, and basically has the following message: Even in times of crisis where it is tempting to (temporarily) lower data protection standards for purposes of big data analytics, there are technical methods to keep data protection standards high. And those technical methods are practical and available.", "cite_spans": [], "ref_spans": [], "section": "Concluding discussion"}, {"text": "An actual roll-out needs to consider a number of other aspects that are out of scope for this article. This includes legal aspects, e.g. making sure there is a consent in using collected telephone numbers for such a purpose. There are also parameters of our system that need to be chosen in view of a particular dataset, potentially in coordination with data-protection authorities such as fixing the minimum Hamming weight of the query vector c and differential privacy parameters.", "cite_spans": [], "ref_spans": [], "section": "Concluding discussion"}, {"text": "In this section we list the BFV parameters used in our implementation.", "cite_spans": [], "ref_spans": [], "section": "A BFV parameters"}, {"text": "In our benchmarks, we use two different plaintext moduli, one with a size of 33 bits, the other with a size of 60 bits. Table 5 lists the used moduli. ", "cite_spans": [], "ref_spans": [{"start": 120, "end": 127, "text": "Table 5", "ref_id": "TABREF6"}], "section": "A.1 Plaintext Moduli"}, {"text": "In this section we list all the ciphertext moduli used for different security levels \u03bb and reduction polynomial degrees n. In SEAL the ciphertext modulus q is the product several primes q i : q = i q i . n = 4096, \u03bb = 80: The ciphertext modulus q is composed of 3 primes with a total size of 162 bit, which we list in Table 6 . Table 6 : Primes composing the ciphertext modulus for n = 4096, \u03bb = 80 in hexadecimal notation and their size in bits.", "cite_spans": [], "ref_spans": [{"start": 318, "end": 325, "text": "Table 6", "ref_id": null}, {"start": 328, "end": 335, "text": "Table 6", "ref_id": null}], "section": "A.2 Ciphertext Moduli"}, {"text": "i qi log2(qi) 1 0x3ffffffffd6001 54 2 0x3ffffffffd2001 54 3 0x3ffffffffbe001 54 n = 8192, \u03bb = 80: The ciphertext modulus q is composed of 7 primes with a total size of 329 bit, which we list in Table 7 .", "cite_spans": [], "ref_spans": [{"start": 194, "end": 201, "text": "Table 7", "ref_id": "TABREF7"}], "section": "A.2 Ciphertext Moduli"}, {"text": "n = 8192, \u03bb = 128: The ciphertext modulus q is composed of 5 primes with a total size of 218 bit, which we list in Table 8 . n = 16384, \u03bb = 128: The ciphertext modulus q is composed of 9 primes with a total size of 438 bit, which we list in Table 9 . ", "cite_spans": [], "ref_spans": [{"start": 115, "end": 122, "text": "Table 8", "ref_id": "TABREF8"}, {"start": 241, "end": 248, "text": "Table 9", "ref_id": "TABREF9"}], "section": "A.2 Ciphertext Moduli"}], "bib_entries": {"BIBREF0": {"ref_id": "b0", "title": "Pandemic contact tracing apps: Dp-3t, pepp-pt ntk, and robert from a privacy perspective", "authors": [{"first": "F", "middle": [], "last": "Aisec", "suffix": ""}], "year": null, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF1": {"ref_id": "b1", "title": "On the concrete hardness of learning with errors", "authors": [{"first": "M", "middle": ["R"], "last": "Albrecht", "suffix": ""}, {"first": "R", "middle": [], "last": "Player", "suffix": ""}, {"first": "S", "middle": [], "last": "Scott", "suffix": ""}], "year": 2015, "venue": "J. Mathematical Cryptology", "volume": "9", "issn": "3", "pages": "169--203", "other_ids": {}}, "BIBREF2": {"ref_id": "b2", "title": "PIR with compressed queries and amortized query processing", "authors": [{"first": "S", "middle": [], "last": "Angel", "suffix": ""}, {"first": "H", "middle": [], "last": "Chen", "suffix": ""}, {"first": "K", "middle": [], "last": "Laine", "suffix": ""}, {"first": "S", "middle": ["T V"], "last": "Setty", "suffix": ""}], "year": 2018, "venue": "IEEE Symposium on Security and Privacy", "volume": "", "issn": "", "pages": "962--979", "other_ids": {}}, "BIBREF3": {"ref_id": "b3", "title": "Breaking the o(n1/(2k-1)) barrier for information-theoretic private information retrieval", "authors": [{"first": "A", "middle": [], "last": "Beimel", "suffix": ""}, {"first": "Y", "middle": [], "last": "Ishai", "suffix": ""}, {"first": "E", "middle": [], "last": "Kushilevitz", "suffix": ""}, {"first": "J", "middle": [], "last": "Raymond", "suffix": ""}], "year": 2002, "venue": "FOCS", "volume": "", "issn": "", "pages": "261--270", "other_ids": {}}, "BIBREF4": {"ref_id": "b4", "title": "Homomorphic training of 30, 000 logistic regression models", "authors": [{"first": "F", "middle": [], "last": "Bergamaschi", "suffix": ""}, {"first": "S", "middle": [], "last": "Halevi", "suffix": ""}, {"first": "T", "middle": ["T"], "last": "Halevi", "suffix": ""}, {"first": "H", "middle": [], "last": "Hunt", "suffix": ""}], "year": 2019, "venue": "ACNS. Lecture Notes in Computer Science", "volume": "11464", "issn": "", "pages": "592--611", "other_ids": {}}, "BIBREF5": {"ref_id": "b5", "title": "Assessing disease exposure risk with location data: A proposal for cryptographic preservation of privacy", "authors": [{"first": "A", "middle": [], "last": "Berke", "suffix": ""}, {"first": "M", "middle": [], "last": "Bakker", "suffix": ""}, {"first": "P", "middle": [], "last": "Vepakomma", "suffix": ""}, {"first": "K", "middle": [], "last": "Larson", "suffix": ""}, {"first": "A", "middle": ["S"], "last": "Pentland", "suffix": ""}], "year": 2020, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF6": {"ref_id": "b6", "title": "Contra corona: Contact tracing against the coronavirus by bridging the centralized-decentralized divide for stronger privacy", "authors": [{"first": "W", "middle": [], "last": "Beskorovajnov", "suffix": ""}, {"first": "F", "middle": [], "last": "D\u00f6rre", "suffix": ""}, {"first": "G", "middle": [], "last": "Hartung", "suffix": ""}, {"first": "A", "middle": [], "last": "Koch", "suffix": ""}, {"first": "J", "middle": [], "last": "M\u00fcller-Quade", "suffix": ""}, {"first": "T", "middle": [], "last": "Strufe", "suffix": ""}], "year": 2020, "venue": "Cryptology ePrint Archive", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF7": {"ref_id": "b7", "title": "ngraph-he2: A highthroughput framework for neural network inference on encrypted data", "authors": [{"first": "F", "middle": [], "last": "Boemer", "suffix": ""}, {"first": "A", "middle": [], "last": "Costache", "suffix": ""}, {"first": "R", "middle": [], "last": "Cammarota", "suffix": ""}, {"first": "C", "middle": [], "last": "Wierzynski", "suffix": ""}], "year": 2019, "venue": "WAHC@CCS", "volume": "", "issn": "", "pages": "45--56", "other_ids": {}}, "BIBREF8": {"ref_id": "b8", "title": "Fast homomorphic evaluation of deep discretized neural networks", "authors": [{"first": "F", "middle": [], "last": "Bourse", "suffix": ""}, {"first": "M", "middle": [], "last": "Minelli", "suffix": ""}, {"first": "M", "middle": [], "last": "Minihold", "suffix": ""}, {"first": "P", "middle": [], "last": "Paillier", "suffix": ""}], "year": 2018, "venue": "CRYPTO (3)", "volume": "10993", "issn": "", "pages": "483--512", "other_ids": {}}, "BIBREF9": {"ref_id": "b9", "title": "Decentralized contact tracing using a dht and blind signatures", "authors": [{"first": "S", "middle": [], "last": "Brack", "suffix": ""}, {"first": "L", "middle": [], "last": "Reichert", "suffix": ""}, {"first": "B", "middle": [], "last": "Scheuermann", "suffix": ""}], "year": 2020, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF10": {"ref_id": "b10", "title": "Fully homomorphic encryption without modulus switching from classical gapsvp", "authors": [{"first": "Z", "middle": [], "last": "Brakerski", "suffix": ""}], "year": 2012, "venue": "CRYPTO. Lecture Notes in Computer Science", "volume": "7417", "issn": "", "pages": "868--886", "other_ids": {}}, "BIBREF11": {"ref_id": "b11", "title": "(leveled) fully homomorphic encryption without bootstrapping", "authors": [{"first": "Z", "middle": [], "last": "Brakerski", "suffix": ""}, {"first": "C", "middle": [], "last": "Gentry", "suffix": ""}, {"first": "V", "middle": [], "last": "Vaikuntanathan", "suffix": ""}], "year": 2012, "venue": "ITCS", "volume": "", "issn": "", "pages": "309--325", "other_ids": {}}, "BIBREF12": {"ref_id": "b12", "title": "Bulletproofs: Short proofs for confidential transactions and more", "authors": [{"first": "B", "middle": [], "last": "B\u00fcnz", "suffix": ""}, {"first": "J", "middle": [], "last": "Bootle", "suffix": ""}, {"first": "D", "middle": [], "last": "Boneh", "suffix": ""}, {"first": "A", "middle": [], "last": "Poelstra", "suffix": ""}, {"first": "P", "middle": [], "last": "Wuille", "suffix": ""}, {"first": "G", "middle": [], "last": "Maxwell", "suffix": ""}], "year": 2018, "venue": "IEEE Symposium on Security and Privacy", "volume": "", "issn": "", "pages": "315--334", "other_ids": {}}, "BIBREF13": {"ref_id": "b13", "title": "Computationally private information retrieval with polylogarithmic communication", "authors": [{"first": "C", "middle": [], "last": "Cachin", "suffix": ""}, {"first": "S", "middle": [], "last": "Micali", "suffix": ""}, {"first": "M", "middle": [], "last": "Stadler", "suffix": ""}], "year": 1999, "venue": "EUROCRYPT. Lecture Notes in Computer Science", "volume": "1592", "issn": "", "pages": "402--414", "other_ids": {}}, "BIBREF14": {"ref_id": "b14", "title": "Anonymous collocation discovery: Harnessing privacy to tame the coronavirus", "authors": [{"first": "R", "middle": [], "last": "Canetti", "suffix": ""}, {"first": "A", "middle": [], "last": "Trachtenberg", "suffix": ""}, {"first": "M", "middle": [], "last": "Varia", "suffix": ""}], "year": 2020, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF15": {"ref_id": "b15", "title": "Pact: Privacy sensitive protocols and mechanisms for mobile contact tracing", "authors": [{"first": "J", "middle": [], "last": "Chan", "suffix": ""}, {"first": "D", "middle": [], "last": "Foster", "suffix": ""}, {"first": "S", "middle": [], "last": "Gollakota", "suffix": ""}, {"first": "E", "middle": [], "last": "Horvitz", "suffix": ""}, {"first": "J", "middle": [], "last": "Jaeger", "suffix": ""}, {"first": "S", "middle": [], "last": "Kakade", "suffix": ""}, {"first": "T", "middle": [], "last": "Kohno", "suffix": ""}, {"first": "J", "middle": [], "last": "Langford", "suffix": ""}, {"first": "J", "middle": [], "last": "Larson", "suffix": ""}, {"first": "S", "middle": [], "last": "Singanamalla", "suffix": ""}, {"first": "J", "middle": [], "last": "Sunshine", "suffix": ""}, {"first": "S", "middle": [], "last": "Tessaro", "suffix": ""}], "year": 2020, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF16": {"ref_id": "b16", "title": "Labeled PSI from fully homomorphic encryption with malicious security", "authors": [{"first": "H", "middle": [], "last": "Chen", "suffix": ""}, {"first": "Z", "middle": [], "last": "Huang", "suffix": ""}, {"first": "K", "middle": [], "last": "Laine", "suffix": ""}, {"first": "P", "middle": [], "last": "Rindal", "suffix": ""}], "year": 2018, "venue": "ACM Conference on Computer and Communications Security", "volume": "", "issn": "", "pages": "1223--1237", "other_ids": {}}, "BIBREF17": {"ref_id": "b17", "title": "Homomorphic encryption for arithmetic of approximate numbers", "authors": [{"first": "J", "middle": ["H"], "last": "Cheon", "suffix": ""}, {"first": "A", "middle": [], "last": "Kim", "suffix": ""}, {"first": "M", "middle": [], "last": "Kim", "suffix": ""}, {"first": "Y", "middle": ["S"], "last": "Song", "suffix": ""}], "year": 2017, "venue": "ASIACRYPT (1)", "volume": "10624", "issn": "", "pages": "409--437", "other_ids": {}}, "BIBREF18": {"ref_id": "b18", "title": "Faster fully homomorphic encryption: Bootstrapping in less than 0.1 seconds", "authors": [{"first": "I", "middle": [], "last": "Chillotti", "suffix": ""}, {"first": "N", "middle": [], "last": "Gama", "suffix": ""}, {"first": "M", "middle": [], "last": "Georgieva", "suffix": ""}, {"first": "M", "middle": [], "last": "Izabach\u00e8ne", "suffix": ""}], "year": 2016, "venue": "ASIACRYPT (1)", "volume": "10031", "issn": "", "pages": "3--33", "other_ids": {}}, "BIBREF19": {"ref_id": "b19", "title": "Private information retrieval", "authors": [{"first": "B", "middle": [], "last": "Chor", "suffix": ""}, {"first": "O", "middle": [], "last": "Goldreich", "suffix": ""}, {"first": "E", "middle": [], "last": "Kushilevitz", "suffix": ""}, {"first": "M", "middle": [], "last": "Sudan", "suffix": ""}], "year": 1995, "venue": "FOCS", "volume": "", "issn": "", "pages": "41--50", "other_ids": {}}, "BIBREF20": {"ref_id": "b20", "title": "Faster cryptonets: Leveraging sparsity for real-world encrypted inference", "authors": [{"first": "E", "middle": [], "last": "Chou", "suffix": ""}, {"first": "J", "middle": [], "last": "Beal", "suffix": ""}, {"first": "D", "middle": [], "last": "Levy", "suffix": ""}, {"first": "S", "middle": [], "last": "Yeung", "suffix": ""}, {"first": "A", "middle": [], "last": "Haque", "suffix": ""}, {"first": "L", "middle": [], "last": "Fei-Fei", "suffix": ""}], "year": 2018, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF21": {"ref_id": "b21", "title": "Applicability of mobile contact tracing in fighting pandemic (covid-19): Issues, challenges and solutions. Cryptology ePrint Archive", "authors": [{"first": "A", "middle": ["B"], "last": "Dar", "suffix": ""}, {"first": "A", "middle": ["H"], "last": "Lone", "suffix": ""}, {"first": "S", "middle": [], "last": "Zahoor", "suffix": ""}, {"first": "A", "middle": ["A"], "last": "Khan", "suffix": ""}, {"first": "R", "middle": [], "last": "Naaz", "suffix": ""}], "year": 2020, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF22": {"ref_id": "b22", "title": "CHET: an optimizing compiler for fully-homomorphic neural-network inferencing", "authors": [{"first": "R", "middle": [], "last": "Dathathri", "suffix": ""}, {"first": "O", "middle": [], "last": "Saarikivi", "suffix": ""}, {"first": "H", "middle": [], "last": "Chen", "suffix": ""}, {"first": "K", "middle": [], "last": "Laine", "suffix": ""}, {"first": "K", "middle": ["E"], "last": "Lauter", "suffix": ""}, {"first": "S", "middle": [], "last": "Maleki", "suffix": ""}, {"first": "M", "middle": [], "last": "Musuvathi", "suffix": ""}, {"first": "T", "middle": [], "last": "Mytkowicz", "suffix": ""}], "year": 2019, "venue": "", "volume": "", "issn": "", "pages": "142--156", "other_ids": {}}, "BIBREF23": {"ref_id": "b23", "title": "RAID-PIR: practical multi-server PIR", "authors": [{"first": "D", "middle": [], "last": "Demmler", "suffix": ""}, {"first": "A", "middle": [], "last": "Herzberg", "suffix": ""}, {"first": "T", "middle": [], "last": "Schneider", "suffix": ""}], "year": 2014, "venue": "", "volume": "", "issn": "", "pages": "45--56", "other_ids": {}}, "BIBREF24": {"ref_id": "b24", "title": "Optimally robust private information retrieval", "authors": [{"first": "C", "middle": [], "last": "Devet", "suffix": ""}, {"first": "I", "middle": [], "last": "Goldberg", "suffix": ""}, {"first": "N", "middle": [], "last": "Heninger", "suffix": ""}], "year": 2012, "venue": "USENIX Security Symposium", "volume": "", "issn": "", "pages": "269--283", "other_ids": {}}, "BIBREF25": {"ref_id": "b25", "title": "A fast single server private information retrieval protocol with low communication cost", "authors": [{"first": "C", "middle": [], "last": "Dong", "suffix": ""}, {"first": "L", "middle": [], "last": "Chen", "suffix": ""}], "year": 2014, "venue": "ESORICS (1)", "volume": "8712", "issn": "", "pages": "380--399", "other_ids": {}}, "BIBREF26": {"ref_id": "b26", "title": "Differential privacy. In: ICALP (2)", "authors": [{"first": "C", "middle": [], "last": "Dwork", "suffix": ""}], "year": 2006, "venue": "", "volume": "4052", "issn": "", "pages": "1--12", "other_ids": {}}, "BIBREF27": {"ref_id": "b27", "title": "Somewhat practical fully homomorphic encryption. IACR Cryptology ePrint Archive", "authors": [{"first": "J", "middle": [], "last": "Fan", "suffix": ""}, {"first": "F", "middle": [], "last": "Vercauteren", "suffix": ""}], "year": 2012, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF28": {"ref_id": "b28", "title": "Fully homomorphic encryption using ideal lattices", "authors": [{"first": "C", "middle": [], "last": "Gentry", "suffix": ""}], "year": 2009, "venue": "STOC", "volume": "", "issn": "", "pages": "169--178", "other_ids": {}}, "BIBREF29": {"ref_id": "b29", "title": "Improving the robustness of private information retrieval", "authors": [{"first": "I", "middle": [], "last": "Goldberg", "suffix": ""}], "year": 2007, "venue": "IEEE Symposium on Security and Privacy", "volume": "", "issn": "", "pages": "131--148", "other_ids": {}}, "BIBREF30": {"ref_id": "b30", "title": "Apple and google's exposure notification system", "authors": [{"first": "Apple", "middle": [], "last": "Google", "suffix": ""}], "year": 2020, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF31": {"ref_id": "b31", "title": "Algorithms in helib", "authors": [{"first": "S", "middle": [], "last": "Halevi", "suffix": ""}, {"first": "V", "middle": [], "last": "Shoup", "suffix": ""}], "year": 2014, "venue": "CRYPTO (1)", "volume": "8616", "issn": "", "pages": "554--571", "other_ids": {}}, "BIBREF32": {"ref_id": "b32", "title": "Bootstrapping for helib", "authors": [{"first": "S", "middle": [], "last": "Halevi", "suffix": ""}, {"first": "V", "middle": [], "last": "Shoup", "suffix": ""}], "year": 2015, "venue": "EUROCRYPT (1)", "volume": "9056", "issn": "", "pages": "641--670", "other_ids": {}}, "BIBREF33": {"ref_id": "b33", "title": "Faster homomorphic linear transformations in helib", "authors": [{"first": "S", "middle": [], "last": "Halevi", "suffix": ""}, {"first": "V", "middle": [], "last": "Shoup", "suffix": ""}], "year": 2018, "venue": "CRYPTO (1)", "volume": "10991", "issn": "", "pages": "93--120", "other_ids": {}}, "BIBREF34": {"ref_id": "b34", "title": "Deep neural networks classification over encrypted data", "authors": [{"first": "E", "middle": [], "last": "Hesamifard", "suffix": ""}, {"first": "H", "middle": [], "last": "Takabi", "suffix": ""}, {"first": "M", "middle": [], "last": "Ghasemi", "suffix": ""}], "year": 2019, "venue": "", "volume": "", "issn": "", "pages": "97--108", "other_ids": {}}, "BIBREF35": {"ref_id": "b35", "title": "Secure outsourced matrix computation and application to neural networks", "authors": [{"first": "X", "middle": [], "last": "Jiang", "suffix": ""}, {"first": "M", "middle": [], "last": "Kim", "suffix": ""}, {"first": "K", "middle": ["E"], "last": "Lauter", "suffix": ""}, {"first": "Y", "middle": [], "last": "Song", "suffix": ""}], "year": 2018, "venue": "ACM Conference on Computer and Communications Security", "volume": "", "issn": "", "pages": "1209--1222", "other_ids": {}}, "BIBREF36": {"ref_id": "b36", "title": "GAZELLE: A low latency framework for secure neural network inference", "authors": [{"first": "C", "middle": [], "last": "Juvekar", "suffix": ""}, {"first": "V", "middle": [], "last": "Vaikuntanathan", "suffix": ""}, {"first": "A", "middle": [], "last": "Chandrakasan", "suffix": ""}], "year": 2018, "venue": "USENIX Security Symposium", "volume": "", "issn": "", "pages": "1651--1669", "other_ids": {}}, "BIBREF37": {"ref_id": "b37", "title": "Optimal rate private information retrieval from homomorphic encryption", "authors": [{"first": "A", "middle": [], "last": "Kiayias", "suffix": ""}, {"first": "N", "middle": [], "last": "Leonardos", "suffix": ""}, {"first": "H", "middle": [], "last": "Lipmaa", "suffix": ""}, {"first": "K", "middle": [], "last": "Pavlyk", "suffix": ""}, {"first": "Q", "middle": [], "last": "Tang", "suffix": ""}], "year": 2015, "venue": "PoPETs", "volume": "2015", "issn": "2", "pages": "222--243", "other_ids": {}}, "BIBREF38": {"ref_id": "b38", "title": "Looking beyond contact tracing to stop the spread", "authors": [{"first": "S", "middle": [], "last": "Landau", "suffix": ""}], "year": 2020, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF39": {"ref_id": "b39", "title": "First CPIR protocol with data-dependent computation", "authors": [{"first": "H", "middle": [], "last": "Lipmaa", "suffix": ""}], "year": 2009, "venue": "In: ICISC. Lecture Notes in Computer Science", "volume": "5984", "issn": "", "pages": "193--210", "other_ids": {}}, "BIBREF40": {"ref_id": "b40", "title": "A simpler rate-optimal CPIR protocol", "authors": [{"first": "H", "middle": [], "last": "Lipmaa", "suffix": ""}, {"first": "K", "middle": [], "last": "Pavlyk", "suffix": ""}], "year": 2017, "venue": "Financial Cryptography", "volume": "10322", "issn": "", "pages": "621--638", "other_ids": {}}, "BIBREF41": {"ref_id": "b41", "title": "On ideal lattices and learning with errors over rings", "authors": [{"first": "V", "middle": [], "last": "Lyubashevsky", "suffix": ""}, {"first": "C", "middle": [], "last": "Peikert", "suffix": ""}, {"first": "O", "middle": [], "last": "Regev", "suffix": ""}], "year": 2010, "venue": "EUROCRYPT. Lecture Notes in Computer Science", "volume": "6110", "issn": "", "pages": "1--23", "other_ids": {}}, "BIBREF42": {"ref_id": "b42", "title": "XPIR : Private information retrieval for everyone", "authors": [{"first": "C", "middle": ["A"], "last": "Melchor", "suffix": ""}, {"first": "J", "middle": [], "last": "Barrier", "suffix": ""}, {"first": "L", "middle": [], "last": "Fousse", "suffix": ""}, {"first": "M", "middle": [], "last": "Killijian", "suffix": ""}], "year": 2016, "venue": "PoPETs", "volume": "2016", "issn": "2", "pages": "155--174", "other_ids": {}}, "BIBREF43": {"ref_id": "b43", "title": "Public-key cryptosystems based on composite degree residuosity classes", "authors": [{"first": "P", "middle": [], "last": "Paillier", "suffix": ""}], "year": 1999, "venue": "EUROCRYPT. Lecture Notes in Computer Science", "volume": "1592", "issn": "", "pages": "223--238", "other_ids": {}}, "BIBREF44": {"ref_id": "b44", "title": "Hashomer -a proposal for a privacy-preserving bluetooth based contact tracing scheme for hamagen", "authors": [{"first": "B", "middle": [], "last": "Pinkas", "suffix": ""}, {"first": "E", "middle": [], "last": "Ronen", "suffix": ""}], "year": 2020, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF45": {"ref_id": "b45", "title": "On lattices, learning with errors, random linear codes, and cryptography", "authors": [{"first": "O", "middle": [], "last": "Regev", "suffix": ""}], "year": 2005, "venue": "STOC", "volume": "", "issn": "", "pages": "84--93", "other_ids": {}}, "BIBREF46": {"ref_id": "b46", "title": "On data banks and privacy homomorphisms. Foundations of Secure Computation", "authors": [{"first": "R", "middle": ["L"], "last": "Rivest", "suffix": ""}, {"first": "L", "middle": [], "last": "Adleman", "suffix": ""}, {"first": "M", "middle": ["L"], "last": "Dertouzos", "suffix": ""}], "year": 1978, "venue": "", "volume": "", "issn": "", "pages": "169--179", "other_ids": {}}, "BIBREF47": {"ref_id": "b47", "title": "A method for obtaining digital signatures and public-key cryptosystems", "authors": [{"first": "R", "middle": ["L"], "last": "Rivest", "suffix": ""}, {"first": "A", "middle": [], "last": "Shamir", "suffix": ""}, {"first": "L", "middle": ["M"], "last": "Adleman", "suffix": ""}], "year": 1978, "venue": "Commun. ACM", "volume": "21", "issn": "2", "pages": "120--126", "other_ids": {}}, "BIBREF49": {"ref_id": "b49", "title": "Decentralized privacy-preserving proximity tracing", "authors": [{"first": "D", "middle": ["T"], "last": "Team", "suffix": ""}], "year": 2020, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF50": {"ref_id": "b50", "title": "Epione: Lightweight contact tracing with strong privacy", "authors": [{"first": "N", "middle": [], "last": "Trieu", "suffix": ""}, {"first": "K", "middle": [], "last": "Shehata", "suffix": ""}, {"first": "P", "middle": [], "last": "Saxena", "suffix": ""}, {"first": "R", "middle": [], "last": "Shokri", "suffix": ""}, {"first": "D", "middle": [], "last": "Song", "suffix": ""}], "year": 2020, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF51": {"ref_id": "b51", "title": "Single-database private information retrieval from fully homomorphic encryption", "authors": [{"first": "X", "middle": [], "last": "Yi", "suffix": ""}, {"first": "M", "middle": ["G"], "last": "Kaosar", "suffix": ""}, {"first": "R", "middle": [], "last": "Paulet", "suffix": ""}, {"first": "E", "middle": [], "last": "Bertino", "suffix": ""}], "year": 2013, "venue": "IEEE Trans. Knowl. Data Eng", "volume": "25", "issn": "5", "pages": "1125--1134", "other_ids": {}}}, "ref_entries": {"FIGREF0": {"text": "sends {yi, i} i\u2208[N ] to the client. 2. Client sets vi = 1 if {x1, . . . , x\u03bd } \u2229 yi = \u2205 and 0 otherwise, for all i \u2208 [N ]. 3. Client computes ci \u2190 HE.Encsk(vi) for all i \u2208 [N ], and sends {ci} i\u2208[N ] to server. 4. Server sets d \u2190 HE.Evalevk c \u2212 1 N If interactive == TRUE: Server chooses zi, yi, ri, \u03c1i $ \u2190 Zp, computes", "latex": null, "type": "figure"}, "FIGREF1": {"text": "Full description of our APIR protocol.", "latex": null, "type": "figure"}, "FIGREF2": {"text": ", . . . , x\u03bd ) Input: (y1, . . . , yN ), Z = (zij)", "latex": null, "type": "figure"}, "FIGREF3": {"text": "Private Sars-CoV-2 Heat Map.", "latex": null, "type": "figure"}, "FIGREF4": {"text": ") diag(Z, i) in equation 8 expresses the i-th diagonal of matrix Z in a vector of size m and rot(v, i) rotates the vector v by index i to the left.However, rotations are very expensive in terms of computational effort in the BFV encryption scheme. Luckily, the diagonal method can further be improved1 2", "latex": null, "type": "figure"}, "FIGREF5": {"text": "Effect of rotations to the inner structure of a BFV ciphertext with n slots.", "latex": null, "type": "figure"}, "TABREF0": {"text": "computes h * j \u2190 HE.Evalevk h * j + j , and sends {h * j } j\u2208[k] to the client. 8. Client computes hj \u2190 HE.Decsk(h * j ) for j \u2208 [k] and outputs {hj} j\u2208[k] .", "latex": null, "type": "table"}, "TABREF2": {"text": "Runtime for the Data Aggregation Phase for different matrix dimensions using only one thread.", "latex": null, "type": "table", "html": "<html><body><table><tr><td>\u00a0</td><td>BFV </td><td>Matrix </td><td>#MatMul </td><td>Runtime\n</td></tr><tr><td>Nr. log2(p) log2(q) </td><td>n \u03bb </td><td>N </td><td>k </td><td>\u00a0</td><td>sec\n</td></tr><tr><td>1 33 </td><td>218 </td><td>8192 128 </td><td>8192 </td><td>4096 </td><td>1 </td><td>17.4\n</td></tr><tr><td>2 33 </td><td>218 </td><td>8192 128 </td><td>40960 </td><td>4096 </td><td>5 </td><td>87.1\n</td></tr><tr><td>3 33 </td><td>218 </td><td>8192 128 </td><td>81920 </td><td>4096 </td><td>10 </td><td>173.1\n</td></tr><tr><td>4 33 </td><td>218 </td><td>8192 128 </td><td>163840 </td><td>4096 </td><td>20 </td><td>359.5\n</td></tr><tr><td>5 33 </td><td>218 </td><td>8192 128 </td><td>8192 20480 </td><td>\u00a0</td><td>5 </td><td>88.3\n</td></tr><tr><td>6 33 </td><td>218 </td><td>8192 128 </td><td>8192 40960 </td><td>\u00a0</td><td>10 </td><td>172.5\n</td></tr><tr><td>7 33 </td><td>218 </td><td>8192 128 </td><td>8192 81920 </td><td>\u00a0</td><td>20 </td><td>349.4\n</td></tr><tr><td>8 33 </td><td>218 </td><td>8192 128 </td><td>40960 20480 </td><td>\u00a0</td><td>25 </td><td>434.7\n</td></tr><tr><td>\u00a0</td><td>9 33 </td><td>218 </td><td>8192 128 </td><td>98304 32768 </td><td>96 </td><td>1778.9\n</td></tr></table></body></html>"}, "TABREF3": {"text": "Runtime for the Data Aggregation Phase for different parameters using 88 threads. The column Masking indicates whether this parameter set is only able to evaluate the matrix multiplication (), or is additionally able to evaluate the calculation of the masking values ( ).", "latex": null, "type": "table"}, "TABREF4": {"text": "Data transmission in MiB for the different parameters inTable 2. Values include keys for evaluating the masking value when applicable.", "latex": null, "type": "table"}, "TABREF5": {"text": "Runtime for the challenge mask computation different parameters using s + 1 threads.", "latex": null, "type": "table"}, "TABREF6": {"text": "Used plaintext moduli in hexadecimal notation and their size in bits.", "latex": null, "type": "table", "html": "<html><body><table><tr><td>Nr. </td><td>p </td><td>log2(p)\n</td></tr><tr><td>1 </td><td>0x1e21a0001 </td><td>33\n</td></tr><tr><td>2 </td><td>0xf4fc03ff53d0001 </td><td>60\n</td></tr></table></body></html>"}, "TABREF7": {"text": "Primes composing the ciphertext modulus for n = 8192, \u03bb = 80 in hexadecimal notation and their size in bits.", "latex": null, "type": "table"}, "TABREF8": {"text": "Primes composing the ciphertext modulus for n = 8192, \u03bb = 128 in hexadecimal notation and their size in bits.", "latex": null, "type": "table", "html": "<html><body><table><tr><td>i qi </td><td>log2(qi)\n</td></tr><tr><td>1 0x7fffffd8001 </td><td>43\n</td></tr><tr><td>2 0x7fffffc8001 </td><td>43\n</td></tr><tr><td>3 0xfffffffc001 </td><td>44\n</td></tr><tr><td>4 0xffffff6c001 </td><td>44\n</td></tr><tr><td>5 0xfffffebc001 </td><td>44\n</td></tr></table></body></html>"}, "TABREF9": {"text": "Primes composing the ciphertext modulus for n = 16384, \u03bb = 128 in hexadecimal notation and their size in bits.", "latex": null, "type": "table", "html": "<html><body><table><tr><td>i qi </td><td>log2(qi)\n</td></tr><tr><td>1 0xfffffffd8001 </td><td>48\n</td></tr><tr><td>2 0xfffffffa0001 </td><td>48\n</td></tr><tr><td>3 0xfffffff00001 </td><td>48\n</td></tr><tr><td>4 0x1fffffff68001 </td><td>49\n</td></tr><tr><td>5 0x1fffffff50001 </td><td>49\n</td></tr><tr><td>6 0x1ffffffee8001 </td><td>49\n</td></tr><tr><td>7 0x1ffffffea0001 </td><td>49\n</td></tr><tr><td>8 0x1ffffffe88001 </td><td>49\n</td></tr><tr><td>9 0x1ffffffe48001 </td><td>49\n</td></tr></table></body></html>"}}, "back_matter": [{"text": "This work was supported by EU's Horizon 2020 project Safe-DEED, grant agreement n \u2022 825225, and EU's Horizon 2020 project TRUSTS, grant agreement n \u2022 871481, and by the \"DDAI\" COMET Module within the COMET -Competence Centers for Excellent Technologies Programme, funded by the Austrian Federal Ministry for Transport, Innovation and Technology (bmvit), the Austrian Federal Ministry for Digital and Economic Affairs (bmdw), the Austrian Research Promotion Agency (FFG), the province of Styria (SFG) and partners from industry and academia. The COMET Programme is managed by FFG.", "cite_spans": [], "ref_spans": [], "section": "Acknowledgments"}]}